:source-highlighter: highlightjs
:imagesdir: images
:numbered:
:unsafe:
:icons: font
:allow-uri-read:

ifdef::env-github[]
:outfilesuffix: .adoc
:caution-caption: :fire:
:important-caption: :exclamation:
:note-caption: :paperclip:
:tip-caption: :bulb:
:warning-caption: :warning:
endif::[]

ifdef::env-github[]
IMPORTANT: ACESSE O TUTORIAL ONLINE http://manoelcampos.com/sd-webservices/4.4-ws-rest-cadastro/[NESTE LINK]. **O ACESSO DIRETAMENTE PELO GITHUB NÃO PERMITE A EXIBIÇÃO DE VÍDEOS.**
endif::[]

= Desenvolvimento Web Services REST em Java utilizando JAX-RS com JPA e CDI no NetBeans (link:https://kinolien.github.io/gitzip/?download=/manoelcampos/sd-webservices/tree/master/4.4-ws-rest-cadastro[zip])
por Manoel Campos da Silva Filho

REST se tornou o padrão de fato para o desenvolvimento de Web Services (WS's) há alguns anos, em oposição ao protocolo SOAP padronizado pela W3C.
Isto se deve a diversos fatores como:

- Troca de mensagens simplificadas entre cliente e servidor, normalmente utilizando JSON no lugar de XML. Isto faz com o tráfego de dados e o delay causado pela troca de mensagens sejam reduzidos. Tais características são fundamentais para dispositivos móveis que normalmente possuem pacotes de dados com tráfego e velocidade limitados.
- Utilização apenas dos recursos do protocolo HTTP para troca de mensagens, sem precisar empacotar os dados da requisição no cabeçalho de outro protocolo como o SOAP, que apenas aumenta o tamanho dos pacotes de dados sendo enviados.
- Utilização de URLs convencionalmente amigáveis, tornando muito simples o teste de clientes REST utilizando ferramentas de linha de comando como curl ou outras como plugins para navegadores.
- Ampla adoção pelo mercado, tornando-o um padrão de fato, amplamente suportado pela comunidade de software livre com a disponibilização de inúmeras bibliotecas e suporte nos mais conhecidos IDEs do mercado.
- Grandes empresas como Google, Facebook, Twitter, Yahoo e muitas outras fornecem incontáveis serviços REST para as mais variadas finalidades. Tais WS's fornecem desde integração com serviços como Google Maps, YouTube e Google Translator, informações sobre previsão do tempo e cotação de moedas (inclusive de criptomoedas como Bitcoin), etc.

Por estes motivos, SOAP se tornou absoleto, dando lugar ao REST. Desta forma, neste tutorial será mostrado o desenvolvimento de uma aplicação servidora e outra cliente utilizando o padrão REST. Será mostrado um passo-a-passo para criar as aplicações do zero, explicando as tecnologias utilizadas e configurações necessárias. Então vamos lá.

== Ferramentas Necessárias

Para este projeto vamos utilizar as seguintes ferramentas:

. JDK 1.8 (a maioria dos servidores de aplicação ainda não suporta versões mais recentes do JDK)
. http://netbeans.apache.org[IDE NetBeans 11]
. Servidor de aplicação GlassFish 5 (a ser mostrado como instalar)

Considera-se que você já tem os itens 1 e 2 previamente instalados.

=== MySQL Server

Nossa aplicação servidora utilizará um banco de dados MySQL, apesar que qualquer outro banco pode ser utilizado. Se estiver utilizando Linux, como Ubuntu, basta fazer o download do MySQL Server via apt-get com o comando abaixo:

[source,bash]
----
sudo apt-get install mysql-server
----

Se estiver usando Windows ou macOS, pode baixar o instalador do
MySQL Server Community https://dev.mysql.com/downloads/mysql/[aqui].
Certifique-se de conferir qual a versão do MySQL está sendo baixada,
pois existem diferenças de configuração para as versões 5 e 8 que serão discutidas adiante.
No Linux, basta digitar `mysql --version` no terminal.

==== Criando o Banco de Dados

Utilize o NetBeans para criar o banco de dados chamado `cadastro-rest` para o nosso sistema, acessando a aba "Services".

ifdef::env-github[]
O processo é mostrado neste https://youtu.be/g0R11_1Fv1I[vídeo].
endif::[]

ifndef::env-github[]
O processo é mostrado no vídeo a seguir.

video::g0R11_1Fv1I[youtube, 800, 600]
endif::[]

IMPORTANT: Não precisaremos criar as tabelas manualmente, como veremos a seguir.

=== GlassFish 5

Vamos utilizar o GlassFish 5 por ser a última versão até o momento de elaboração deste tutorial. 

ifdef::env-github[]
Este https://youtu.be/_Af4RK9UvRw[vídeo] mostra os passos para instalar o GlassFish 5 .
endif::[]

ifndef::env-github[]
O vídeo a seguir mostra os passos para instalar o GlassFish 5.

video::_Af4RK9UvRw[youtube, 800, 600]
endif::[]

Como vamos usar o MySQL como banco de dados, precisaremos do MySQL Connector J, driver JBDC do MySQL (que vai ser utilizado internamente para acesso ao BD). Baixe o driver no https://dev.mysql.com/downloads/connector/j/[site oficial].

Após descompactar o driver, o único arquivo que nos interessa é o `mysql-connector-java-X.X.X-bin.jar` (onde X.X.X é a versão do driver). Copie tal arquivo para a pasta `glassfish5/glassfish/domains/domain1/lib` (considerando que `glassfish5` é a pasta onde descompactou o GlassFish). As bibliotecas colocadas em tal pasta serão carregadas automaticamente pelo GlassFish.

== Estrutura do projeto

Utilizaremos o https://pt.wikipedia.org/wiki/Hibernate[Hibernate] como framework de https://pt.wikipedia.org/wiki/Mapeamento_objeto-relacional[mapeamento objeto relacional (Object Relational Mapping - ORM)], que é uma implementação da especificação https://pt.wikipedia.org/wiki/Java_Persistence_API[JPA]. Ele nos permite "esquecer" os detalhes de BDs relacionais (como SQL, Primary Keys (PKs), Foreign Keys (FKs), criação de tabelas, etc) e assim podermos trabalhar exclusivamente em um modelo orientado a objetos, mesmo para manipulação dos dados no banco.

A especificação http://cdi-spec.org[Context and Dependency Injection (CDI)] permite que objetos sejam injetados (ou seja, criados automaticamente) onde precisarmos. Tal especificação é implementada por padrão em servidores de aplicação como o GlassFish ou WildFly. 

CDI permite diminuir o acoplamento de um software, ou seja, reduz o nível de dependência do nosso projeto. Por exemplo, a partir do momento que utilizamos a especificação JPA como camada de persistência (para salvarmos os dados em algum lugar, neste caso em um BD), se instanciarmos diretamente no nosso código objetos JPA para fazer tais operações, estamos aumentando o nível de dependência do nosso projeto, tornando ele fortemente dependente da JPA. Se precisamos, por exemplo, persistir certos objetos em outro repositório, como em arquivos no disco, precisaríamos instanciar explicitamente objetos diferentes para realizar tal tarefa. 

Com CDI, podemos simplesmente declarar um objeto e indicar que queremos que uma instância de tal objeto seja injetada automaticamente quando tal objeto precisar ser usado. Com isto, podemos ter um arquivo de configuração separado que define qual instância será injetada quando um objeto de um determinado tipo for solicitado. Se precisarmos mudar o tipo de objeto (como objetos que usam JPA para persistir dados em um BD por objetos que simplesmente salvam dados em um arquivo), podemos alterar isso em apenas um lugar do código. Observe que utilizei o termo "tipo" e não "classe", uma vez que este tipo pode ser tanto uma classe quanto uma interface, sendo interfaces comumente mais utilizadas.

O CDI também nos livra de termos que utilizar o operador `new` sempre que precisarmos usar um deteminado objeto.

== O projeto

O projeto que desenvolveremos será bem simples. O diagrama de classe abaixo mostra que teremos apenas duas classes de negócio `Usuario` e `Cidade`. O servidor disponibilizará um cadastro de usuários por meio de um Web Service REST. A classe `Usuario` tem apenas dados básicos e mais um atributo que indica a cidade onde ele mora. 

Existe uma interface `Cadastro` que será implementada por todas as classes que representarem tabelas no BD. Tal interface apenas define  um getter e setter para um atributo `id` que cada classe de negócio terá. Assim, estamos definindo que todas essas classes devem ter um atributo `id`, que será bastante útil posteriormente.

image::class-diagram.jpg[title=Diagrama das Classes de Negócio]

== Iniciando o Desenvolvimento

Vamos criar um projeto Maven de uma Web Application no NetBeans, como mostra a animação abaixo.

image::create-project.gif[]

O campo `groupId` na penúltima tela de criação do projeto foi preenchido com `com.manoelcampos` indicando um nome de domínio invertido para identificar a empresa ou pessoa que desenvolveu o projeto. Caso você tenha um domínio, pode utilizar. Caso não tenho, pode inventar um ou usar qualquer nome que desejar. O campo `package` é automaticamente formado pela junção do `groupId` com o nome dado para o projeto no primeiro campo.

Se nunca utilizou Maven antes, esta é uma ferramenta para gerenciamento de dependências no seu projeto, permitindo baixar as dependências indicadas automaticamente. Não confunda com o CDI que usaremos para injeção de dependências. No Maven dizemos quais bibliotecas nosso projeto precisa. Usando CDI, dizemos quais objetos devem ser injetados (automaticamente instanciados) quando precisarmos deles.

=== Criando as classes de negócio

Agora vamos criar as classes `Usuario` e `Cidade`. Primeiro vamos criar a classe `Usuario` dentro de um subpacote chamado `model`, onde colocaremos todas as classes de negócio (que representam o modelo do negócio).

image::create-business-class.gif[]

Veja que apenas adicionamos `.model` ao final do nome do pacote ao criar a classe. Agora crie a classe `Cidade` dentro deste pacote `model`. 

Como tais classes representarão tabelas no BD, cada uma delas deve ter um atributo `id` (neste caso, este id representa uma chave primária simples). Para isso, vamos criar uma interface chamada `Cadastro` que define métodos getter e setter para este atributo de tais classes. Tal interface ficará no mesmo pacote das classes e terá o seguinte código:

[source, java]
----
public interface Cadastro {
    long getId();
    void setId(long id);
}
----

Vamos então indicar que nossas classes `Usuario` e `Cidade` implementam tal interface.

image::implement-interface-methods.gif[]

Como estas classes agora precisam implementar os métodos na interface, podemos usar o NetBeans para incluir o corpo dos métodos pra nós, como mostrado acima. Faça o mesmo para as duas classes de negócio.

Nossa classe `Usuario` terá apenas os atributos abaixo, com os respectivos getters e setters. 

[source, java]
----
    private long id;
    private String nome;
    private String cpf;

    @ManyToOne
    private Cidade cidade;
----

Observe que na classe `Usuario` temos um atributo do tipo `Cidade`. Isto representa um relacionamento entre as duas classes. Neste caso, a cardinalidade da associação entre `Usuario` e `Cidade` (nesta direção) é n..1, ou seja, muitos usuários são de uma mesma cidade. Para representar tal associação precisamos usar a anotação `@ManyToOne` no atributo. Desta forma, no banco de dados será criada uma chave estrangeira dentro da tabela `Usuario` para armazenar o id da `Cidade`. 

Podemos usar o NetBeans para criar tais métodos para gente. Temos apenas que apagar o código gerado para os métodos `getId()` e `setId()` e definir o código apropriado.

image::encapsulating-fields.gif[]

Faça o mesmo para a classe `Cidade`, definindo os atributos abaixo:

[source, java]
----
    private long id;
    private String nome;
    private String uf;
----

=== Utilizando a JPA para acesso ao Banco de Dados

Como falado, a JPA é uma especificação Java que provê uma forma padrão para a implementação de frameworks de ORM como o Hibernate. Assim, se usarmos JPA, podemos trocar o framework por qualquer outro que implementa tal especificação, sem precisarmos alterar nosso código fonte (apenas configurações serão necessárias).

Para usarmos a JPA, e posteriormente o Hibernate em segundo plano, para fazer toda a comunicação com o BD, precisamos indicar quais classes representam tabelas no BD. Nossas classes de negócio `Usuario` e `Cidade` serão as únicas a serem mapeadas para tabelas no banco (por isso chama-se mapeamento objeto-relacional, pois mapeia-se objetos para um BD relacional como o MySQL).

Para indicarmos que uma classe será mapeada, precisamos marcá-la com a anotação `@Entity` da JPA, definindo a classe como uma entidade (uma tabela no BD). Tal anotação precisa ser colocada imediatamente antes da declaração da classe. Após incluí-la, precisaremos importar tal anotação. Novamente podemos usar o NetBeans para isso, clicando na lâmpada que aparece no lado esquerdo da linha, como mostrado abaixo.

image::define-entity.gif[]

Observe que após salvarmos, é apresentado um erro na linha da declaração da classe. Passando o mouse no erro destacado em vermelho, podemos ver que está sendo indicado que não há nenhum atributo `ID` para a entidade. Podemos clicar na lâmpada e usar o NetBeans para definir um `ID`, como mostra a animação acima. 

Já temos um atributo que chamamos de `id` e que representa a identificação única de cada objeto da classe (ou seja, a PK na tabela do BD). Assim, apenas indicamos que queremos usar um campo existente como `ID` e então selecionamos o campo chamado `id`. Com isto, uma anotação `@Id` é colocada no campo.

Para indicarmos que desejamos que o valor deste campo seja gerado automaticamente no BD (para que ele seja definido como autoincrement no MySQL), vamos adicionar a anotação `@GeneretedValue`, indicando que a estatégia para geração do valor do campo será `IDENTITY`. O atributo `id` deve ficar como abaixo. 

[source, java]
----
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private long id;
----

As classes anotadas com `@Entity` (que a partir de agora, por simplificação chamaremos apenas de Entity) devem implementar a interface `Serializable`, indicando que objetos de tais classes podem ser persistidos (salvos). Também podemos usar o NetBeans para fazer essa modificação para nós.

image::implement-serializable.gif[]

O mesmo processo de definir uma entidade, um `ID` e implementar `Serializable` deve ser aplicado para todas as classes de negócio.

=== Definindo uma Persistence Unit (PU)

Projetos utilizando JPA precisam conter uma Persistence Unit (PU), que é uma arquivo chamado `persistence.xml` definindo as configurações para acesso ao BD, controle de transações, provedor de persistência a ser utilizado e outras configurações. Ele é o arquivo de configuração da JPA.

Uma vez que já temos algumas Entities no nosso projeto, podemos facilmente adicionar uma PU utilizando o NetBeans,
como mostra este link:https://youtu.be/7y\--ODvjdjQ[vídeo].

video::7y--ODvjdjQ[youtube, 800, 600]

No vídeo acima, definimos o nome da PU como `default` (um nome mais simples que o sugerido pelo NetBeans). Como teremos apenas uma PU no nosso projeto (para acessar um único BD), não precisaremos nos preocupar com este nome. Escolhemos o Persistence Provider como Hibernate (JPA 2.1), indicando que o Hibernate será a implementação da JPA que utilizaremos. No campo Data Source devemos escolher ou configurar uma conexão com o BD. Um Data Source (DS) é uma fábrica de conexões com o BD. 

Temos então que criar primeiro um DS. Chamamos tal DataSource de "cadastro-rest-ds" e selecionamos a conexão com o BD (configurada quando criamos o banco "cadastro-rest"). O nome do DS é utilizado na PU para poder instanciar uma conexão com o banco. Após abrir o arquivo `persistence.xml` (que representa as configurações da PU), o NetBeans mostra um editor gráfico para tal arquivo.

image::persistence-unit.png[]

Alguns pontos importantes são:

- *Persistence Provider*: definimos que desejamos usar Hibernate (como dito antes), como implementação da JPA. 
- *Use Java Transaction APIs*: esta opção indica que nossa aplicação usará a JTA. Esta é uma API implementada por servidores de aplicação como o GlassFish, para prover controle automático de transações para nossa aplicação. Isto quer dizer que não teremos que nos preocupar em abrir, cancelar ou confirmar transações no BD. Tudo isso será feito automaticamente pelo GlassFish.
- *Table Generation Strategy*: está como "Create" para permitir que, ao rodar a aplicação, as tabelas sejam criadas no BD automaticamente. Depois que elas tiverem sido criadas, podemos alterar para "None". A opção "Drop and Create" só é interessante se não houver dados que desejamos manter no banco. Assim, sempre que exercutarmos a aplicação, as tabelas serão apagadas e recriadas.

Há apenas alguns detalhes que precisamos observar. Se clicarmos no botão "Source" na parte superior do arquivo, podemos visualizar todo o código XML gerado. Quando escolhemos o Hibernate, o valor da tag `<provider>` foi definido como `org.hibernate.ejb.HibernatePersistence`, porém, tal provider está obsoleto nas versões atuais do Hibernate e deve ser trocado para `org.hibernate.jpa.HibernatePersistenceProvider`.

O provider representa o nome qualificado (incluindo o nome do pacote) da classe que é capaz de criar objetos `EntityManagerFactory` e a estrutura de tabelas no BD. Um `EntityManagerFactory` é uma fábrica de objetos `EntityManager`. Um `EntityManager` (EM), por sua vez, é responsável por gerenciar o ciclo de vida das entidades como `Usuario` e `Cidade` no nosso sistema. Um EM permite, por exemplo, buscar, incluir, alterar e excluir objetos do BD.     

Por fim, como indicamos que desejamos usar a JTA, da mesma forma que precisamos indicar qual era a classe que implementa o Persistence Provider, precisamos indicar qual a classe que implementa a JTA Platform, responsável por gerenciar as transações no BD.

Como estamos utilizando GlassFish, precisamos adicionar na tag `<properties>` a seguinte propriedade:

[source, xml]
----
<property name="hibernate.transaction.jta.platform" value="org.hibernate.service.jta.platform.internal.SunOneJtaPlatform"/>
----

Esta é a classe do GlassFish que implementa a JTA Platform.

=== Configurando o CDI

Para permitir o uso de CDI, até o JavaEE 6 era obrigatória a existência de um arquivo chamado `beans.xml`. A partir do JavaEE 7 tal arquivo não é obrigatório, mas podemos criá-lo se quisermos adicionar algumas configurações para o CDI.

Pelo menu `File >> New File` do NetBeans, podemos digitar `beans.xml` na janela de pesquisa para criar o arquivo. O arquivo possui um atributo chamado `bean-discovery-mode` que é definido com valor igual a `annotated`.

Isto indica que só podemos injetar objetos que estejam marcados com alguma anotação que define o escopo dos objetos a serem injetados. Algumas anotações de escopo disponibilizadas pelo CDI, que controlam o ciclo de vida de objetos, são o `@ApplicationScoped` e `@RequestScoped`. Um objeto marcado com `@ApplicationScoped` será criado quando requisitado e só será destruído quando a aplicação for finalizada. Um objeto marcado com `@RequestScoped` será criado sempre que for requisitado e será destruído ao final da requisição. Se não marcarmos um objeto com nenhum anotação de escopo, seu escopo é `@Dependent`, que indica que seu ciclo de vida depende do ciclo de vida do objeto onde ele foi criado.

Para não sermos obrigados a anotar todas as classes que desejamos criar objetos por injeção e assim tornar mais fácil o uso de CDI, podemos alterar o valor do atributo para `all`. Assim, poderemos injetar objetos de qualquer classe que desejarmos.

IMPORTANT: Em aplicações com uma grande quantidade de classes, usar `bean-discovery-mode=all` pode causar https://weld.cdi-spec.org/news/2016/10/25/tip3-performance/[maior consumo de memória e maior tempo de inicialização].

=== Adicionando dependências Maven

O arquivo `pom.xml` (criando automaticamente quando criamos o projeto Maven) é onde indicamos quais são as dependências do nosso projeto. Como estamos utilizando o Hibernate, precisamos incluir as dependências a seguir dentro da tag `<dependencies>`:

[source, xml]
----
        <dependency>
            <groupId>org.hibernate.javax.persistence</groupId>
            <artifactId>hibernate-jpa-2.1-api</artifactId>
            <version>1.0.2.Final</version>
        </dependency>
        <dependency>
            <groupId>org.hibernate</groupId>
            <artifactId>hibernate-core</artifactId>
            <version>5.4.12.Final</version>
        </dependency>
        <dependency>
            <groupId>org.hibernate</groupId>
            <artifactId>hibernate-entitymanager</artifactId>
            <version>5.4.12.Final</version>
        </dependency>
----

O uso de CDI não nos dispensa de declarar as dependências do nosso projeto. O CDI também não vai reduzir o número de dependências. Nosso projeto continua dependendo daquilo que ele usa. O que o CDI garante é que seja fácil trocar a implementação de uma dependência por outra, sem precisar alterar o código, mas somente as configurações como acima.

Nosso projeto depende de uma implementação da JPA. Usaremos CDI para injetar objetos que implementam a especificação JPA. Neste caso, tais objetos são de classes implementadas pelo Hibernate, que é o chamado Persistence Provider. Se decidirmos trocar o Hibernate por outra implementação (como o EclipseLink), trocamos apenas as dependências e configurações no `persistence.xml` e o CDI se encarregará de injetar os objetos criados pelo provider (como o `EntityManager` discutido anteriormente).

=== Instanciando um EntityManager para manipular dados no BD

A classe `EntityManager`, como dito anteriormente, controla o ciclo de vida de Entities (classes de negócio anotadas com `@Entity`) e permite persistir tais objetos no BD. Para instanciar um `EntityManager` precisaríamos de um objeto `EntityManagerFactory` que é uma fábrica de `EntityManagers`. No entanto, usando CDI, podemos injetar `EntityManagers` automaticamente, sempre que seu uso for necessário, sem precisarmos recorrer a um `EntityManagerFactory`. 

Podemos injetar `EntityMangers` em classes que tenham o ciclo de vida controlado pelo servidor de aplicação. Para isso, precisaríamos declarar um objeto `EntityManager` e anotá-lo com `@PersistenceContext`. Porém, teríamos que utilizar esta anotação em todos os locais onde declarassemos tal objeto. Para não termos que fazer isso e centralizarmos o processo de injeção de qualquer `EntityManager` em um só lugar, vamos criar uma classe `Producers` dentro do pacote `com.manoelcampos.server.config`. A classe e o pacote podem ter qualquer nome que desejar. Esta classe representa um produtor (fábrica) de objetos e usará recursos do CDI para definir como determinados objetos mais complexos, como um `EntityManager`, devem ser criados. A classe deve ter o código apresentado a seguir:

[source, java]
----
package com.manoelcampos.server.config;

import javax.enterprise.inject.Produces;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;

public class Producers {
    @Produces 
    @PersistenceContext
    private EntityManager em;
}
----

O código acima declara um `EntityManager` (EM) e o anota com `@PersistenceContext`. Assim, o EM será gerenciado pelo servidor de aplicação (que é chamado de https://eclipse-ee4j.github.io/jakartaee-tutorial/persistence-intro004.html#BNBQZ[Container-managed EntityManager]) e automaticamente injetado quando requisitado, utilizando as configurações definidas no `persistence.xml`. Como temos apenas uma Persistence Unit (PU) dentro de tal arquivo, não precisamos nos preocupar em definir o nome de tal PU ao anotar o `EntityManager`. Mas se quisessemos explicitar o nome da PU (que não é recomendável, pois este pode ser renomeado no arquivo xml), poderíamos alterar a anotação para `@PersistenceContext(name = "default")`, onde `default` foi o nome que demos pra nossa PU. Mas isso só é aconsolhável se tivermos mais de uma PU no `persistence.xml`.

Observe que o EM também está anotado com `@Produces`. Isto quer dizer que sempre que precisarmos de um EM, uma instância será criada neste atributo `em` e retornado para o local onde foi solicitado.

=== Implementando o padrão DAO

Supondo que estamos desenvolvendo esta aplicação para um determinado cliente, nossas classes de negócio `Usuario` e `Cidade` são classes específicas do negócio do cliente. O EM disponibiliza métodos para persistir objetos no BD. Assim, para incluir, alterar ou excluir um objeto no BD, precisamos chamar estes métodos do EM. 

Para não incluir tal código dentro das classes de negócio (que devem ter apenas código referente ao negócio do cliente), é comum a utilização do padrão https://pt.wikipedia.org/wiki/Objeto_de_acesso_a_dados[Data Access Object (DAO)] para permitir a separação de conceitos (https://pt.wikipedia.org/wiki/Separação_de_conceitos[Separation of Concerns, SoC]). A SoC evita misturar código de um determinado nível de abstração com outros de outro nível. As classes de negócio como `Usuario` podem ter código para validar o CPF, enquanto operações de BD não estão relacionadas com o negócio e assim devem ser mantidas separadas.

Para implementar o padrão DAO, precisaríamos criar uma classe DAO para cada classe de negócio. Assim, teríamos uma classe `UsuarioDAO` e `CidadeDAO`. Como um DAO proverá métodos para manipular dados no BD, como `salvar` e `remover`, tais métodos acabam ficando duplicados entre os DAOs. Para evitar isso, podemos criar um DAO genérico que funciona para qualquer classe de negócio. Isto pode ter suas desvantagens, mas não vamos discutí-las nesse artigo.

Primeiro, vamos definir uma interface chamada DAO, dentro do pacote `com.manoelcampos.server.dao`.

[source, java]
----
package com.manoelcampos.server.dao;

import com.manoelcampos.server.model.Cadastro;

public interface DAO<T extends Cadastro> {
    T findById(long id);
    T findByField(String fieldName, Object value);
    boolean delete(T entity);
    boolean delete(long id);
    long save(T entity);
}
----

Tal interface define métodos para:

- localizar um objeto no BD a partir do seu id: `findById()`;
- localizar por um campo específico: `findByField()`;
- remover: `delete(T entity)` e `delte(long id)`;
- e salvar um objeto no BD e retornar o id gerado: `save()`. 

A interface usa https://www.devmedia.com.br/usando-generics-em-java/28981[Generics] para permitir indicar qual o tipo de objeto de negócio (que implementa a interface `Cadastro`) um DAO trabalhará. Assim, quando mandarmos localizar um `Usuario` utilizando seu id, teremos como retorno um objeto `Usuario` e não um objeto genérico como `Object`. Generics é um assunto bem extenso que está fora do escopo deste artigo.

Agora que definimos uma interface padrão para nossos DAOs, vamos criar uma classe que utilizará JPA para implementar tal interface. Definir a interface e criar uma classe que a implementa é muito útil se desejarmos criar outras formas de persistência para nossos objetos de negócio. Por exemplo, poderíamos desejar persistir os objetos em um BD usando JPA e também em arquivos, utilizando o recurso de serialização do Java. Para isso, poderíamos ter classes DAO implementando diferentes mecanismos de persistência de dados.

Assim, crie a classe `JpaDAO` no pacote `com.manoelcampos.server.dao` como abaixo. Ela usa um `EntityManager` para persistir um objeto de negócio no BD. O tipo de objeto de negócio é definido utilizando Generics, como feito na interface `DAO`.

[source, java]
----
package com.manoelcampos.server.dao;

import com.manoelcampos.server.model.Cadastro;
import javax.persistence.EntityManager;
import javax.persistence.Query;
import javax.persistence.TypedQuery;

public class JpaDAO<T extends Cadastro> implements DAO<T> {
    private final EntityManager em;
    private final Class<T> classe;
    
    public JpaDAO(EntityManager em, Class<T> classe){
        this.em = em;
        this.classe = classe;
    }

    @Override
    public T findById(long id) {
        return em.find(classe, id);
    }

    @Override
    public boolean delete(T entity) {
        em.remove(entity);
        return true;
    }

    @Override
    public boolean delete(long id) {
        T entity = findById(id);
        return delete(entity);
    }

    @Override
    public long save(T entity) {
        if(entity.getId() > 0)
            em.merge(entity);
        else em.persist(entity);
        
        return entity.getId();
    }

    @Override
    public T findByField(String fieldName, Object value) {
        final String jpql = "select o from " + classe.getSimpleName() + " o " +
                            " where o." + fieldName + " = :" + fieldName;
        TypedQuery<T> query = em.createQuery(jpql, classe);
        query.setParameter(fieldName, value);
        return query.getSingleResult();
    }
}
----

Como pode ser observado acima, os métodos para fazer a manipulação dos dados no BD são extremamente simples. 
Alguns métodos merecem maiores esclarecimentos:

- o método `save()` pode tanto inserir ou alterar um objeto no BD. Assim, precisamos saber qual dessas duas operações deve ser realizada. Uma forma simplória (para não complicar as coisas aqui) de fazer isso é verificar se o objeto (parâmetro `entity`) possui um valor pro atributo `id`, ou seja, se tal atributo tem valor maior que zero. 
Neste caso, isto indica que o objeto já existe no BD e precisamos fazer um update chamando o método `em.merge(entity)`. Caso contrário, chamamos o `em.persist(entity)` pra incluir o objeto no BD.
- o método `delete()` possui duas versões: uma que recebe a entidade (objeto) a ser excluído e outra que recebe apenas o id do objeto. Na JPA, para excluir um objeto do banco, precisamos ter uma instância de tal objeto. Usando o método que recebe apenas o id, teremos que primeiro localizar o objeto no banco e então excluir tal objeto. Como no serviço REST o mais fácil é passarmos apenas o id do objeto a ser excluído, é mais simples usar a versão do método que recebe apenas o id.

Já a instanciação de um `JpaDAO` não é tão simples assim. Para criar tal objeto é preciso passar dois parâmetros para o construtor. Sempre que precisarmos instanciar um `JpaDAO`, precisaremos passar estes parâmetros. É nesses casos em que a injeção de dependências tem mais valor.

Quando usamos injeção de dependência com CDI, objetos podem ser criados automaticamente, desde que eles tenham um construtor padrão. Como a classe `JpaDAO` (que é a única implementação da interface `DAO`) não possui um construtor padrão, não podemos injetar objetos `DAO` diretamente. Precisamos criar um código adicional para indicar ao CDI como objetos `DAO` devem ser criados, até porque se tivessemos mais de uma implementação da interface `DAO`, o CDI não saberia qual classe concreta instanciar para injetar um objeto que implementa tal interface.

A grande vantagem é que, apesar de termos um trabalho adicional para informar ao CDI como criar DAOs, teremos que fazer isso em um único lugar, ao invés de ter que passar esses parâmetros para criar um DAO em todo lugar que declararmos um. Para fazer isso, vamos alterar a classe `Producers` como abaixo:

[source, java]
----
package com.manoelcampos.server.config;

import com.manoelcampos.server.dao.DAO;
import com.manoelcampos.server.dao.JpaDAO;
import com.manoelcampos.server.model.Cadastro;
import java.lang.reflect.ParameterizedType;
import javax.enterprise.inject.Produces;
import javax.enterprise.inject.spi.InjectionPoint;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;

public class Producers {
    @Produces 
    @PersistenceContext
    private EntityManager em;
    
    @Produces
    public <T extends Cadastro> DAO<T> getDao(InjectionPoint ip){
        ParameterizedType t = (ParameterizedType) ip.getType();
        Class classe = (Class) t.getActualTypeArguments()[0];
        return new JpaDAO(em, classe);
    }        
}
----

Neste caso, definimos um método anotado com `@Produces`. Isto é necessário pois o CDI não sabe como instanciar um `DAO`, uma vez que esta é uma classe que nós criamos. Por mais que um `EntityManager` seja ainda mais complexo de ser criado, o CDI já tem recursos para instanciar tais objetos pra nós.
O método `getDao` então será chamado automaticamente, toda vez que um objeto `DAO` anotado com `@Inject` precisar ser criado. Lembre que o `@Inject` indica que um objeto deve ser injetado alí.

O parâmetro `ip` que tal método recebe, conterá informações sobre o local onde foi solicitada a injeção do `DAO`. Para declarar um `DAO` (por exemplo, para manipular objetos `Usuario`) temos que escrever `@Inject DAO<Usuario> dao`. A classe entre < e > indica quais objetos de negócio o `DAO` manipulará. Este parâmetro `ip` conterá informações como qual tipo genérico (definido entre < e >) está associado ao `DAO`. Com isto, conseguimos obter a classe entre < e > e assim criar um `DAO` instanciando um objeto `JpaDAO` para manipular objetos de tal classe. Como tal objeto também requer um `EntityManager`, podemos simplesmente acessar o atributo `em` declarado dentro da própria classe `Producers`. Quando fizermos isso, um `EntityManager` será produzido e passado para o `JpaDAO` criado.

=== Configurando o Servidor REST

Para criarmos e executarmos nossos serviços REST, precisamos habilitar o uso de REST no projeto. Para isto, basta criar uma classe como `RestConfig` no pacote `com.manoelcampos.server.config` (o nome da classe e do pacote podem ser qualquer um). Tal classe deve extender `javax.ws.rs.core.Application` e deve ser anotada com `@javax.ws.rs.ApplicationPath("api")`, onde `api` pode ser qualquer nome que indica a raiz a partir da qual os seviços REST estarão disponíveis. Tal classe não precisa ter métodos, construtor nem atributo algum, como mostrado abaixo.

[source, java]
----
package com.manoelcampos.server.config;

import javax.ws.rs.core.Application;

@javax.ws.rs.ApplicationPath("api")
public class RestConfig extends Application {

}
----

Uma vez que estamos rodando o GlassFish localmente e que nosso projeto chama `server`, a URL para acessar a aplicação seria http://localhost:8080/server/. 

Ao executar o projeto, uma página como http://localhost:8080/server/ será acessada. A API REST estará disponível a partir de outro diretório, como especificado na anotação `@javax.ws.rs.ApplicationPath`. Neste caso, a URL base para acesso aos recursos será http://localhost:8080/server/api. Mas não adianta tentar acessar tal URL, pois ela por si só não funciona: precisamos implementar nosso primeiro serviço que vai ser acessar a partir de um caminho adicional depois de tal URL.

=== Implementando o Servidor REST

O serviço REST que vamos implementar vai fornecer as famosas operações CRUD (Create, Read, Update e Delete)
que permite inserir (Criar), obter (Ler), alterar (Atualizar) e deletar registros de uma tabela de um BD.
Como pode ser visto link:../webservices.pptx[nesta apresentação], em serviços REST, tais métodos CRUD devem ser associados a determinados métodos HTTP. A tabela abaixo a associação entre verbos HTTP, operações CRUD e comandos SQL.

|===
|*Verbo (Método) HTTP* |*Operação CRUD* |*Comando SQL*
|POST                  |**C**reate      | insert
|GET                   |**R**ead        | select
|PUT                   |**U**pdate      | update
|DELETE                |**D**elete      | delete
|===

Assim, para cada método a ser implementado na classe do serviço em Java, precisamos indicar qual o verbo HTTP que deve ser usado para acessar o método remotamente.

==== Criando a classe do primeiro serviço REST

Toda a infraestrutura da nossa aplicação está pronta. Agora, vamos criar nosso Web Service (WS) REST. Tal WS disponibilizará operações para manipular usuários no BD, assim como as operações definidas no `DAO`. Web Services REST são acessados normalmente por meio de URLs amigáveis. Cada URL permite realizar operações sobre um determindao recurso, por meio de requisições utilizando os verbos do protocolo HTTP. Cada uma destas URLs é chamada de _endpoints_, que no código Java representam métodos a serem acessados remotamente por meio de requisições HTTP. 

Na terminologia REST, um recurso pode ser um arquivo qualquer, uma imagem, dados obtidos de uma tabela em um BD (como é o nosso caso), etc. Assim, para podermos disponibilizar as operações do `DAO` para objetos `Usuario`, precisamos criar uma classe `UsuarioResource` no pacote `com.manoelcampos.server.rest`, como abaixo.

[source, java]
----
package com.manoelcampos.server.rest;

import com.manoelcampos.server.dao.DAO;
import com.manoelcampos.server.model.Usuario;
import javax.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;

@Path("/usuario")
public class UsuarioResource {
    @Inject 
    private DAO<Usuario> dao;
    
    @GET
    @Path("{id}")
    @Produces(MediaType.APPLICATION_JSON)
    public Usuario findById(@PathParam("id") long id) {
        return dao.findById(id);
    }
}
----

Para publicar tal classe como um recurso acessível via HTTP, precisamos incluir a anotação `@Path` antes da declaração da classe e indicar o caminho que será utilizado para acessar tal recurso por meio de uma URL. Neste caso, indicamos que um recurso `Usuario` poderá ser acessado a partir do caminho `/usuario`. O acesso ao recurso só acontece quando um determinado método da classe é executado. Cada método então define um caminho adicional a partir de `/usuario` que permitirá que o método seja chamado por uma requisição HTTP. No caso do método `findById` (que possui o mesmo nome que no `DAO`), ele será acessado a partir de `/usuario/{id}`, onde `{id}` representa o id do usuário que deseja-se obter. 

[IMPORTANT]
====
A URL para acesso a um determinado método é formada pela:

- URL base da aplicação, normalmente http://localhost:8080/NomeDaAplicacao
- mais o caminho (`@Path`) base do serviço REST, definido na classe `RestConfig` como `api`
- mais o caminho da classe do serviço
- mais o caminho do método a ser acessado

Assim, a URL completa para acesso ao método `findById()` da classe `UsuarioResource` seria algo como http://localhost:8080/server/api/usuario/{id}, onde {id} deve ser substituído pelo id do usuário que deseja-se obter.
====

Observe que o método `findById` possui um parâmetro id. Quando utilizamos a anotação `@Path` para indicar qual o caminho a ser utilizado para acessar tal método via HTTP, definimos o nome como `{id}` (entre chaves), para indicar que `id` deve ser um valor a ser passado na URL após `/usuario`. Esta valor será passado automaticamente para o parâmetro id do método, uma vez que utilizamos a tag `@PathParam` para indicar isso. Note que no `@PathParam` não se usa chaves. Assim, se acessarmos uma URL terminada em `/usuario/1`, estamos querendo obter o usuário de id igual a 1. Assim, o valor para o parâmetro `id` é obtido a partir da URL e passado para o parâmetro id no método.

IMPORTANT: Certifique-se de incluir a anotação `@PathParam` correta, do pacote `javax.ws.rs`. Como existe uma anotação de mesmo nome no pacote `javax.websocket.server`, incluir esta vai causar o erro _"The request entity cannot be empty"_. Tal erro indica que o parâmetro anotado com a `@PathParam` incorreta não recebeu o valor passado pela URL (como especificado na anotação `@Path` do método `findById()`).

Este método está anotado com `@Produces`, para indicar que o retorno do método deve ser convertido para JSON.
Esta anotação não é a mesma `@Produces` vista anteriormente para o CDI. Apesar de ter o mesmo nome, a finalidade é outra.
A anotação `@Produces` do JAX-RS é usada para indicar que formato deve ser usado para converter os dados retornados por um método. Como o mais usual em serviços REST é o formato JSON, usamos tal anotação para que o JAX-RS faça a conversão do objeto usuário retornado pelo método `findById()` para JSON.
Assim, tenha certeza de importar a anotação `@Produces` do pacote `javax.ws.rs.Produces` e não a anotação do CDI.

Por fim, também anotamos o método `findById()` com `@GET` para indicar que este método só aceita requisições HTTP com o verbo GET. Se utilizarmos um verbo que o método não aceita, receberemos o erro _"405 Method Not Allowed_", ou seja "Erro HTTP 405: Método (Verbo) não Permitido".

==== Implementando método para inserir usuário

Definimos que o método `findById()` será acessado remotamente por meio do verbo GET do HTTP. Assim, estamos implementando a operação Read do CRUD. Como já temos o DAO implementando as operações CRUD, é bastante simples disponibilizar tais operações no nosso serviço REST. Vamos começar adicionando o método insert na classe `UsuarioResource`.

[source, java]
----
@POST
@Consumes(MediaType.APPLICATION_JSON)
public long insert(Usuario usuario) {
    return dao.save(usuario);
}
----

De acordo com a tabela mostrada anteriormente, para inserir um registro no banco (operação Create do CRUD), devemos usar o verbo POST do HTTP, anotando o método `insert()` com `@POST`. Neste caso, não incluímos uma anotação `@Path` pois não queremos que seja utilizado um caminho adicional, além do já existente `/usuario`, para inserir um usuário no banco. Se acessarmos tal URL por meio do verbo POST, o servidor REST entenderá que queremos chamar o método `insert()` mostrado acima.
Neste caso, como vamos passar um usuário a ser inserido no banco, o parâmetro do `insert()` é um objeto da classe `Usuario` e não um id numérico. 

IMPORTANT: Tenha certeza de importar a anotação `@POST` correta, do pacote `javax.ws.rs`. Importando outra anotação que possa aparecer nas opções do IDE irá fazer com que o projeto não compile.

No caso de requisições POST, os dados passados não vão na URL (como no verbo GET). Assim, não usamos a anotação `@PathParam` no parâmetro do método e nem incluímos parâmetro algum na anotação `@Path`. Até porque, neste exemplo não quisemos definir um caminho adicional para acessar o método, logo, não precisamos da `@Path`.

Observe que anotamos o método `insert()` com `@Consumes` e não `@Produces`, pois este método consome (recebe) dados em formato JSON, no lugar de produzir (retornar) dados em JSON. Como o método está retornando um tipo primitivo (o id do usuário inserido), não precisamos converter o retorno para JSON. Assim, o método apenas consome JSON.

[TIP]
====
Uma dica fácil para saber qual anotação usar é: 

- quando o método recebe um objeto, ele vai consumir (`@Consumes`);
- quando retorna um objeto ele vai produzir (`@Produces`).
====

=== Executando a aplicação

Antes de acessar uma URL de um método de um serviço REST implementado, precisamos clicar no botão `Build` para compilar todo o projeto. Sempre que salvamos o projeto, as classes alteradas são compiladas e o projeto é reimplantado (_redeployed_) automaticamente. Normalmente, como fizemos inúmeras alterações no projeto e nunca executamos o mesmo, é aconselhável clicar no botão `Clean and Build` (Limpar e Construir) para apagar quaisquer versões anteriores das classes compiladas e implantar as novas. Muitos erros ocorrem quando fazemos alterações estruturais no projeto (como mudar nome de classes e métodos, remover métodos, mudar parâmetros, etc) e não usamos tal botão. Agora, podemos clicar no botão `Play` (F6) para executar o projeto. Sem isso, o WS REST não poderá ser acessadso.

Ao executar o projeto, uma página como http://localhost:8080/server/ será exibida, apenas pelo fato de um arquivo index.html ser criado automaticamente quando criamos o projeto. Então, esta página de fato não exibirá nada. A API REST estará disponível a partir de um caminho adicional. Já sabemos que a URL base dos serviços REST será http://localhost:8080/server/api/PathDeUmRecurso/PathDeUmMetodo. 

Então, para acessar o método `findById` do recurso `Usuario`, a URL completa seria algo como http://localhost:8080/server/api/usuario/1.

Se uma classe como a `RestConfig` (mostrada no início da seção) não foi criada, o NetBeans dará um aviso na linha da declaração de qualquer classe anotada com `@Path` e permitirá adicionar a classe de configuração automaticamente. Esta é uma forma simples de não precisarmos ter que lembrar como deve ser esta classe `RestConfig`. Apenas lembre que a classe não precisa ter método algum. 

Usando este assistente do NetBeans, ele adicionará código dentro de tal classe que de fato não funcionará (pelo menos não para as versões de bibliotecas e ferramentas utilizadas). Assim, se usar tal assistente para criar a classe, apague qualquer método e atributo adicionado. Lembre também de definir o nome pelo qual deseja acessar os recursos por meio de REST, dentro da anotação `@ApplicationPath()`. No nosso caso definimos o caminho como _"api"_. 

== Testando o serviço criado

Para testar o serviço REST, podemos desenvolver uma aplicação cliente em qualquer linguagem que desejarmos,
para qualquer plataforma (web, mobile, desktop). O projeto link:client[cliente] é um exemplo de uma aplicação
de linha de comando em Java que consome tal serviço.

Testar um método REST que usa o verbo HTTP GET é trivial: basta digitar a URL do método, passando os devidos parâmetros.
No entanto, quando um método usa outro verbo HTTP, não conseguimos testar desta forma.
Se você não quiser criar uma aplicação cliente apenas para testar o serviço, existem várias alternativas para isto.
A forma mais simples, que não requer instalação de nenhuma ferramenta adicional, é usando o 
site https://postwoman.io

=== Usando a ferramenta de linha de comando curl

O curl é uma ferramenta que já vem instalada na maioria das distribuições Linux.
Abaixo mostro como usar o comando curl no terminal para enviar uma requisição HTTP para diferentes métodos
publicados por um serviço REST (como o serviço de usuários desenvolvido aqui). 

|===
|*Método* |*Verbo HTTP* |*Comando curl completo*
|Inserir Usuário  |POST |curl -X POST -d '{"cpf": "99999999999", "nome": "João"}' -H "Content-Type: application/json" http://localhost:8080/server/api/usuario/
|Buscar Usuário  |GET |curl http://localhost:8080/server/api/usuario/1
|Alterar Usuário  |PUT |curl -X PUT -d '{"id": 1, "cpf": "11111111111", "nome": "Maria"}' -H "Content-Type: application/json" http://localhost:8080/server/api/usuario/
|Excluir Usuário  |DELETE |curl -X DELETE http://localhost:8080/server/api/usuario/1
|===

WARNING: Observe que ainda não implementamos os métodos para alterar e excluir usuários (verbos POST e PUT). *No caso da operação de inserir usuários, se tentar acessá-la, verá que ocorrerá um erro. Isto será explicado na próxima seção.*

Para operações POST e PUT, é comum passarmos no corpo da mensagem HTTP o conteúdo a ser enviado na requisição.
Nos exemplos acima, é passado um objeto `Usuario` em formato JSON. Neste caso, precisamos incluir o cabeçalho
`Content-Type` para indicar que estamos enviando um conteúdo em JSON na requisição HTTP.

IMPORTANT: Observe que ao enviar conteúdo JSON, é preciso usar aspas duplas ao redor do nome de atributos e valores. Todo o código JSON deve ser envolvido em aspas simples, não o contrário. Se as aspas forem invertidas, o servidor indicará que o JSON é inválido. 

=== Usando extensões para navegadores Web

Você também pode utilizar o próprio navegador para testar seus serviços REST. Assim, você terá uma interface web amigável e intuitiva, facilitando muito os testes. A seguir são exibidas opções para Firefox e Chrome.

- Para o Firefox você pode baixar o plugin https://addons.mozilla.org/pt-BR/firefox/addon/restclient/[RESTClient].
- Para o Google Chrome utilizo a excelente extensão https://chrome.google.com/webstore/detail/restlet-client-rest-api-t/aejoelaoggembcahagimdiliamlcdmfm/[Talend API Tester (antigo Restlet Client)]. 

A extensão _Talend API Tester_ tem um recurso extremamente útil de permitir criar projetos e salvar diferentes requisições HTTP
dentro deste projeto. Assim, podemos facilmente reenviar tais requisições sem ter que configurá-las novamente.
Muitas vezes, apenas alteramos valores de parâmetros e pronto. A imagem abaixo apresenta um exemplo de um projeto
criado em tal ferramenta.

image:restlet-client-chrome.png[]

Todos os dados usadas nos exemplos de envio de requisição utilizando o comando curl na seção anterior devem
ser utilizados para preencher os campos na tela da extensão que você estiver usando no seu navegador, incluindo:

- o verbo HTTP;
- o conteúdo do corpo da mensagem (como nos casos de POST e PUT)
e cabeçalho para indicar o formato de tal conteúdo (no nosso caso, JSON).

=== Testando o método de incluir usuário

Se você tentar acessar o método `insert()` da classe `UsuarioResource` para incluir um usuário, verá que ocorre a exceção _javax.persistence.TransactionRequiredException_, provavelmente sem apresentar nenhuma mensagem de erro. Tal exceção indica que tentamos executar uma operação que exigia uma transação, mas esta não foi aberta. Neste caso, estamos falando de transações de banco de dados. Como estamos usando JPA, para fazer alguma operação que altera dados no banco, precisamos: 

1. iniciar uma transação; 
2. executar a(s) operação(ões); 
3. se a(s) operação(ões) foi(foram) executada(s) com sucesso, devemos fazer um _commit_ na transação para efetivamente confirmar as alterações no banco;
4. se ocorrer algum erro ocorreu, devemos fazer um _rollback_ para desfazer qualquer operação que tenha sido feita depois que a transação foi iniciada.

Lembra que lá no início configuramos a tal da JTA (Java Transaction API)? Pois é, esta API permite que o servidor de aplicação (GlassFish no nosso caso) controle este ciclo de vida de transações apresentado acima. Assim, não temos que escrever código para definir tais passos. Com a JTA, podemos apenas usar uma simples anotação para indicar que queremos usar transações de banco de dados nas nossas classes de serviços REST e tudo funcionará automaticamente, feito mágica. Costumamos dizer que este tipo de recurso é *automágico* 🤣.

Então, para os métodos de inserção, alteração e exclusão funcionarem, podemos anotar a classe `UsuarioResource` com `@Transactional`.

=== Implementando método para alterar e excluir usuário

Por fim, vamos adicionar o código na classe `UsuarioResource` para os métodos de alteração e exclusão de usuários, como mostrado a seguir.
O código dispensa comentários, pois todos os detalhes já foram explicados na implementação dos métodos anteriores.

[source, java]
----
@PUT
@Consumes(MediaType.APPLICATION_JSON)
public boolean update(Usuario usuario) {
    //Se retornou um id maior que 0, é porque o usuário foi salvo no BD
    return dao.save(usuario) > 0;
}

@DELETE
@Path("{id}")
public boolean delete(@PathParam("id") long id) {
    return dao.delete(id);
}
----

Pronto, agora pode usar alguma das formas mostradas anteriormente para testar qualquer método do serviço REST implementado.
Espero que o tutorial tenha sido completo e esclarecedor.
Se encontrar algum erro, algo que ficou mal explicado ou que pode ser melhorado, basta criar uma nova issue https://github.com/manoelcampos/sd-webservices/issues[aqui].

== Download do código fonte

O código fonte do projeto pode ser baixado como zip link:https://kinolien.github.io/gitzip/?download=/manoelcampos/sd-webservices/tree/master/4.4-ws-rest-cadastro[aqui].